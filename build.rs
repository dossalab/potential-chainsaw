#![allow(dead_code)]

//! This build script creates the memory.x file based on selected chip and
//! SoftDevice right in the directory where the linker expects it

use byte_unit::n_kib_bytes;
use std::env;
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;

// A chip memory layout representation
struct Chip {
    name: &'static str,
    ram_start: u128,
    ram_len: u128,
    flash_start: u128,
    flash_len: u128,
}

// The softdevice, if used, reserves some memory for it's internal purposes
struct SoftDevice {
    name: &'static str,
    reserved_flash: u128,
    reserved_ram: u128,
}

impl Default for SoftDevice {
    fn default() -> Self {
        Self {
            name: "None",
            reserved_flash: 0,
            reserved_ram: 0,
        }
    }
}

// TODO: This is not super reliable... There has to be a better way
#[cfg(not(any(feature = "platform-nrf52832", feature = "platform-nrf52840")))]
compile_error! {
    "You need to select precisely one of the supported platforms.

    Most likely you need to run `cargo build` with --features flag, i.e:
        `cargo build --features platform-nrf52832`

    See Cargo.toml a the list of supported platforms"
}

// These are some of the supported chip and SoftDevice combos
const NRF52_RAM_START: u128 = 0x20000000;

const NRF52832_XXAB: Chip = Chip {
    name: "nrf52832_xxab",
    flash_start: 0,
    ram_start: NRF52_RAM_START,
    flash_len: n_kib_bytes!(256),
    ram_len: n_kib_bytes!(32),
};

const NRF52840: Chip = Chip {
    name: "nrf52840",
    flash_start: 0,
    ram_start: NRF52_RAM_START,
    flash_len: n_kib_bytes!(1024),
    ram_len: n_kib_bytes!(256),
};

const SOFTDEVICE_S132: SoftDevice = SoftDevice {
    name: "S132",
    reserved_flash: n_kib_bytes!(152),
    reserved_ram: 0x3328,
};

// It's better to keep it here because we can preprocess it easier and use calculations
fn write_memory_x(output: &PathBuf, chip: Chip, softdevice: Option<SoftDevice>) {
    let sd = softdevice.unwrap_or_default();
    let memory_x = format!(
        "/* This file is autogenerated by build.rs for '{}' x SoftDevice '{}'. DO NOT MODIFY */
        MEMORY {{
            FLASH : ORIGIN = 0x{:x}, LENGTH = 0x{:x}
            RAM : ORIGIN = 0x{:x}, LENGTH = 0x{:x}
        }}",
        chip.name,
        sd.name,
        chip.flash_start + sd.reserved_flash,
        chip.flash_len - sd.reserved_flash,
        chip.ram_start + sd.reserved_ram,
        chip.ram_len - sd.reserved_ram
    );

    File::create(output.join("memory.x"))
        .unwrap()
        .write(memory_x.as_bytes())
        .unwrap();
}

fn find_chip_softdevice_combo(output: &PathBuf) {
    let chip = if cfg!(feature = "platform-nrf52832") {
        NRF52832_XXAB
    } else if cfg!(feature = "platform-nrf52840") {
        NRF52840
    } else {
        panic!("Such platform is not supported by build.rs or no platforms configured. FIXME");
    };

    let softdevice = if cfg!(feature = "softdevice-s132") {
        Some(SOFTDEVICE_S132)
    } else {
        None
    };

    write_memory_x(output, chip, softdevice);
}

fn main() {
    let output = &PathBuf::from(env::var_os("OUT_DIR").unwrap());

    find_chip_softdevice_combo(output);

    println!("cargo:rustc-link-search={}", output.display());
    println!("cargo:rustc-link-arg-bins=--nmagic");
    println!("cargo:rustc-link-arg-bins=-Tlink.x");
    println!("cargo:rustc-link-arg-bins=-Tdefmt.x");
}
